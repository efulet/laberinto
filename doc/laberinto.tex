%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University/School Laboratory Report
% LaTeX Template
% Version 3.1 (25/3/14)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Linux and Unix Users Group at Virginia Tech Wiki 
% (https://vtluug.org/wiki/Example_LaTeX_chem_lab_report)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%----------------------------------------------------------------------------------------
% PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[letter, titlepage, 10pt]{article}

\usepackage{fancyhdr, graphicx} % Required for the inclusion of images
%\usepackage{natbib} % Required to change bibliography style to APA
\usepackage{amsmath} % Required for some math elements 

\usepackage[spanish]{babel} % Para separar correctamente las palabras
\usepackage[utf8]{inputenc} % Este paquete permite poner acentos y eñes usando c

\usepackage[titletoc,toc,title]{appendix}
\usepackage{titlepic}

\usepackage{caption}
\usepackage{subcaption}

\usepackage{color}
\usepackage[table,xcdraw]{xcolor}

\usepackage{float}
\restylefloat{table}

\definecolor{lightgrey}{rgb}{0.9,0.9,0.9}
\definecolor{darkgreen}{rgb}{0,0.6,0}

\usepackage{listings}
\lstset{language=Python,
        basicstyle={\fontsize{8px}{8px}\ttfamily\bfseries},
        commentstyle=\color{red}\itshape,
        stringstyle=\color{darkgreen},
        showstringspaces=false,
        breaklines=true,
        keywordstyle=\color{blue}
\bfseries}


\setlength\parindent{0pt} % Removes all indentation from paragraphs

\renewcommand{\labelenumi}{\alph{enumi}.} % Make numbering in the enumerate environment by letter rather than number (e.g. section 6)
\newcommand{\abs}[1]{\left\vert#1\right\vert}
%\usepackage{times} % Uncomment to use the Times New Roman font

%----------------------------------------------------------------------------------------
% DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

\textheight=21cm
\textwidth=16.5cm   
\topmargin=-0.5cm
\oddsidemargin=0cm
\parindent=0mm


%--------------------------------------------------------------------------
\title{TALLER I \\ La Aventura de Teseo \\ Resolución de Problemas Basados en Búsqueda} % Title
\author{Brian Keith\\
  \small briankeithn@gmail.com\\
\and
  Exequiel Fuentes\\
  \small efulet@gmail.com\\
}

\titlepic{\includegraphics[bb=0 0 242 246,scale=0.2,keepaspectratio=true]{images/ucn_logo.jpg}}
% ucn_logo.jpg: 2017x2053 pixel, 600dpi, 8.54x8.69 cm, bb=0 0 242 246



%\renewcommand{\headrulewidth}{0pt}
%\fancyhead[L]{\includegraphics[width=5em]{images/logo_c_ucn_small}\hspace{0.3cm}\parbox[b][4em][t]{0.8\textwidth}{Universidad Católica del Norte \\ Departamento de Ingeniería de Sistemas y Computación \\ Magíster en Ingeniería Informática}}
%\fancyhead[R]{}

%\titlehead{\centering\includegraphics[width=6cm]{placeholder}}

\date{\today}
%\publishers{blah}

%\author{Juan  \textsc{Bekios}} % Author name

%\date{\today} % Date for the report

\begin{document}

\maketitle % Insert the title, author and date
%\thispagestyle{fancy}

%\begin{center}
%\begin{tabular}{l r}
%Fecha de Entrega: &  20 de Mayo, 2014 \\ % Date the experiment was performed
%Autor: & Brian Keith \\ & Exequiel Fuentes \\
%Asignatura: & Sistemas Inteligentes\\ % Asignatura
%Profesor: & Juan Bekios-Calfa % Instructor/supervisor
%\end{tabular}
%\end{center}

% If you wish to include an abstract, uncomment the lines below
% \begin{abstract}
% Abstract text
% \end{abstract}

%----------------------------------------------------------------------------------------
% SECTION 1
%----------------------------------------------------------------------------------------

\section{Introducción}
El objetivo del presente trabajo es mostrar el desarrollo del problema del laberinto con Teseo y el Minotauro, utilizando diferentes algoritmos de búsqueda vistos en clases. Se desarrollarán los algoritmos de búsqueda en anchura, profundidad, costo uniforme y A* en Python. 

De manera formal se define la búsqueda como el proceso de examinar diferentes posibles secuencias de acciones que llevan a estados conocidos, y luego escoger la mejor secuencia. Un algoritmo de búsqueda toma un problema como su entrada y retorna una solución en la forma de una secuencia de acciones.

Los algoritmos implementados en este taller encuentran una solución al problema, para el caso de búsqueda en profundidad el camino encontrado puede no ser óptimo, pero para todos los demás se encuentra garantizado que la solución sea óptima. Se utilizó además la librería GASP de Python para mostrar el funcionamiento de los algoritmos gráficamente.

\subsection{Contexto del problema}
El problema propuesto consiste en ayudar a Teseo a encontrar la ruta más corta hacía el minotauro en el laberinto que construyó Dédalo. Una vez encontrado el minotauro, Teseo debe matarle y luego salir por la misma ruta por la que entró. Teseo dispone de la ayuda de Ariadna, una de las hijas del rey Minos, quien le ha enseñado como asesinar a la gran bestia, además, Teseo dispone de un ovillo mágico que le permite guiarse a través del laberinto, marcando la ruta que ha tomado. 

Se debe modelar el enunciado propuesto como un \textbf{problema de búsqueda} y debe resolverse utilizando los distintos algoritmos vistos en clase. Se pretende con esta experiencia comparar el rendimiento de las diferentes estrategias de búsqueda en el problema de Teseo y el minotauro.

\subsection{Experiencias Relacionadas}
Existe una gran cantidad de material referente al tema de búsqueda en internet, los problemas clásicos presentados corresponden a las N-reinas, el puzzle 8 (y sus extensiones), y por supuesto, el laberinto.

Se han encontrado varias experiencias similares al problema del laberinto. Los algoritmos de búsqueda de camino o ``pathfinding'' se utilizan mucho en la programación de vídeo juegos (A* es el algoritmo que se utiliza generalmente para esto). Uno de los problemas similares encontrados consiste en dotar a los fantasmas del juego ``Pacman'' de una rutina de búsqueda basada en el algoritmo A* para encontrar la mejor ruta con la que atacar al jugador. También se debe mencionar el artículo sobre búsqueda de caminos en laberintos de estructura desconocida, donde se hace uso de diferentes algoritmos de búsqueda no informada para encontrar la solución.

Se han encontrado también numerosas soluciones del problema de búsqueda de caminos en laberintos (las cuáles se encuentran referenciadas en la bibliografía). La implementación del taller se ha hecho en base de las soluciones encontradas en la web y del código visto en clases. Se ha utilizado programación orientada a objetos para el desarrollo del taller. Una de las soluciones encontradas utilizaba orientación a objetos, sin embargo, la lógica no se encontraba separada de la presentación. Se han mejorado las soluciones encontradas ya que se ha separado la lógica de la presentación. 

\subsection{Agentes Inteligentes}

Se han implementado dos tipos de agentes inteligentes en este taller:
\begin{itemize}
  \item{\textbf{Agente basado en objetivos: }} Este tipo de agentes realizan búsquedas sin ninguna información extra, es decir, la búsqueda es ciega, debido a esto en el peor caso deben realizar una búsqueda completa del espacio de estados. Se implementaron dos algoritmos siguiendo este enfoque (anchura y profundidad).
  \item{\textbf{Agente basado en utilidad: }}  Este tipo de agentes utilizan una métrica para buscar la solución, en este caso se usará el costo que tiene cada camino. Es importante en este tipo de agentes la definición de las funciones para evaluar los costos. Se implementaron dos algoritmos siguiendo este enfoque (costo uniforme y A*).
\end{itemize}

\subsubsection{Percepciones}
El agente recibirá como percepciones su posición actual, las posibles posiciones a donde puede moverse y además sabe la posición del minotauro. 

\subsubsection{Acciones}
Las acciones que puede realizar el agente son movimientos, puede moverse en las cuatro direcciones básicas (arriba, abajo, izquierda y derecha), a no ser que exista una muralla que se lo impida.

\subsubsection{Objetivos}
El objetivo del agente es recorrer el laberinto para encontrar al minotauro y obtener el camino más corto desde la entrada hasta él. Una vez encontrado el minotauro debe encontrar el camino más corto para la salida, sin embargo, como para esta versión del problema, la salida corresponde a la misma entrada, se debe utilizar el mismo camino original.

\subsubsection{Ambiente}
Se describe a continuación el ambiente, para ello se responde las siguientes preguntas:

\begin{itemize}
%Fuente http://www.cs.stir.ac.uk/courses/31YE/lectures/2%20-%20Environments.pdf
\item ¿El agente puede determinar inequívocamente el estado del entorno?\\
Si bien el agente no puede percibir todo el laberinto desde su posición actual, las percepciones le entregan la información necesaria y suficiente para tomar las decisiones correctas, por lo tanto el ambiente es \textbf{accesible}.

\item ¿Las acciones del agente en un estado actual determinan completamente el estado resultante?\\
Sí, las acciones que realiza el agente determinan por completo el siguiente estado, no existen elementos estocásticos y aleatorios en este ambiente, por lo tanto, el ambiente es \textbf{determinístico}.

\item ¿El estado del entorno puede cambiar mientras que el agente delibera?\\ El entorno no cambia mientras el agente delibera su siguiente movimiento, pues tanto la posición del minotauro como la estructura del laberinto se preservan a lo largo del tiempo, por lo tanto el ambiente es \textbf{estático}. (Diferente sería el problema si es que el minotauro se moviese a lo largo del laberinto en busca de Teseo)

\item ¿Los conjuntos de posibles percepciones y/o acciones son discretas?\\
Los posibles estados del ambiente, al igual que las posibles acciones que puede tomar el agente, forman un conjunto discreto. Por lo tanto el ambiente es \textbf{discreto}.

\item ¿Las acciones que toma el agente en un momento afectan las futuras acciones de este?\\
Sí, cada acción que toma el agente determina las futuras acciones que podrá tomar el agente, es decir, el agente no actúa en episodios independientes de acción cada vez que delibera, por lo tanto, el ambiente es \textbf{secuencial} (no episódico).

\item ¿Cuántos agentes actúan en el ambiente?\\
Se tiene un único agente actuando en el ambiente, por lo tanto, el ambiente es de \textbf{un sólo agente}.
\end{itemize}

\newpage

\section{Diseño de un Agente}

\subsection{Definición formal del problema}
Se definirá primero formalmente el problema de búsqueda de camino en el laberinto será definido de la siguiente forma:

\begin{itemize}
\item Se define un tablero inicial $M$ de dimensiones $MxN$ que representa un laberinto con murallas y caminos en sus posiciones.
\item Se tiene un estado inicial único $S = (x_0, y_0)$.
\item Se tiene un estados final único $F = (x_f, y_f)$ (podría ser posible definir el problema con varios estados finales).
\item Desde la posición inicial se debe llegar a la posición final realizando solo movimientos del tipo: Arriba, Abajo, Derecha e Izquierda.
\item Existe la posibilidad que no haya solución.
\item El objetivo del problema es encontrar un camino de solución óptimo.
\end{itemize}


\begin{description}
  \item[Representación del Laberinto] \hfill \\
  Antes de diseñar el agente propiamente tal, se debe definir una representación para el ambiente. El laberinto es un tablero que se representa mediante una matriz $M$ de dimensiones $N \times M$. Cada entrada $(x,y)$ de la matriz representa una posición en el tablero de laberinto. En cada posición del laberinto se puede tener uno de los siguientes elementos:
    \begin{itemize}
          \item Un ``0'' si es que la posición tiene una muralla.
          \item Un ``1'' si es que la posición está libre y se puede caminar por ella.
          \item Un ``2'' si es que la posición corresponde a la posición inicial de Teseo.
          \item Un ``3'' si es que la posición corresponde a la posición del Minotauro.
          \item Un ``4'' si es que la posición ya ha sido recorrida por Teseo.
    \end{itemize}
  \item[Definición de Estado] \hfill \\
  El estado del problema puede modelarse como la posición actual $X = (x,y)$ de Teseo (el agente) en el laberinto. Es decir un estado puede representarse por $(X, M)$. Notar que las acciones que realice el agente pueden afectar a ciertas posiciones de $M$, causando que ciertas entradas de la matriz pasen a tener el estado ``Recorrida'', se representará este suceso con $M.marcar(a,b)$ donde $(a,b)$ es la posición del laberinto que se debe marcar como recorrida. Esto se hace ya que Teseo debe marcar los lugares que ya ha recorrido. Según las imágenes entregadas en el código de ejemplo se marca con migas, según el enunciado debería usarse un ovillo, se utilizan migas por ser más simples de representar en el laberinto.
   
    \item[Estado Inicial] \hfill \\
    El estado inicial del problema se define de la siguiente forma:
  \begin{displaymath}
    EstadoInicial := \left(X = S, M = M_0\right)
  \end{displaymath}
  Es decir, el agente se encuentra en el estado inicial y el laberinto se encuentra sin cambios.
  
    \item[Acciones] \hfill \\
  El agente puede realizar un único tipo de acción desde su posición actual $(x,y)$. La acción se llama ``Mover'' y se representa con la letra $m$, definida a continuación:
  \begin{center}
    $m(dx,dy) :=$ \{El agente se mueve a la posición $(x+dx,y+dy)$ y se marca la posición $(x,y)$.\}\\
    Se debe cumplir además: $dx + dy = 1$\\
  \end{center}
  Esta definición de acciones limita al agente a realizar saltos de tamaño 1 hacia Arriba, Abajo, Izquierda y Derecha, pero no diagonal. Por último, se debe notar que al realizar una acción mover, el agente debe marcar su antigua posición como recorrida.
  
  \item[Restricciones] \hfill \\
    Se definirán ahora las restricciones del problema. Dada la posición actual del agente $A$ con coordenadas $(x,y)$, la siguiente posición $(x+dx,y+dy)$  deben cumplir con los siguientes requerimientos:
  \begin{align}
    0 \leq x+dx < N\\
    0 \leq y+dy < M\\
    M[x+dx][y+dy] \neq Muro\\
    M[x+dx][y+dy] \neq Recorrido\\
  \end{align}
  Se explicará cada restricción:
  \begin{itemize}
    \item La primera restricción especifica que la nueva posición debe estar dentro del laberinto. (Para el eje X)
    \item La segunda restricción especifica que la nueva posición debe estar dentro del laberinto. (Para el eje Y)
    \item La tercera restricción especifica que la nueva posición no puede ser un muro.
    \item La cuarta restricción especifica que la nueva posición no debe haber sido recorrida previamente. (Esta restricción se impone para que el algoritmo sea más eficiente)
  \end{itemize}

Se muestra a continuación el método que genera los posibles sucesores en una posición.

  \begin{lstlisting}
    def obtener_posiciones_libres(self, posicion_objeto):
        libres = []
        deltaf = [-1, 0, 1, 0]
        deltac = [0, -1, 0, 1]
        for i in xrange(4):
            nuevof = posicion_objeto[0] + deltaf[i]
            nuevoc = posicion_objeto[1] + deltac[i]
            if 0 <= nuevof < self._filas and 0 <= nuevoc < self._columnas:
                if self._mapa[nuevof][nuevoc] == 1 or self._mapa[nuevof][nuevoc] == 3:
                    libres.append([nuevof, nuevoc])

  \end{lstlisting}
  
Los vectores $deltaf$ y $deltac$ almacenan los posibles movimientos, es decir: $\{(-1, 0), (0, -1), (1, 0), (0, 1)\}$ y al iterarse sobre ellos se puede ir generando los diferentes movimientos. Notar que para la implementación, cambiar el orden en que se genera los vectores afecta los resultados de la búsqueda en profundidad, debido a que esta siempre intentará probar con el primer movimiento, a diferencia de las otras búsquedas que se utilizan otros criterios.
  
    \item[Modelo de transición] \hfill \\
    El estado resultante $(X_{n+1},M_{n+1})$ de aplicar la acción $m(dx,dy)$ sobre un estado $(X_{n},M{n})$ del sistema se define de la siguiente forma:
    \begin{displaymath}
      X_{n+1} = (X_{n}.x + dx, X_{n}.y + dy)
    \end{displaymath}
    \begin{displaymath}
      M_{n+1} = M_{n}.marcar(X_{n}.x, X_{n}.y) 
    \end{displaymath}

    Es decir, siempre que se realiza la acción de movimiento se marca también la posición anterior. Si es que el estado cumple con las restricciones definidas anteriormente es un \textbf{estado válido}, en caso contrario es un estado inválido.
   
    \item[Estado Objetivo] \hfill \\
Se define ahora el conjunto de estados objetivos:
    \begin{displaymath}
      EstadosObjetivo := \left\lbrace X = F = (x_f, y_f) \right\rbrace
    \end{displaymath}
Es decir el problema se encuentra resuelto cuando se ha llegado a la posición final.

    \item[Costo del Camino] \hfill \\
    El costo del camino corresponde a la cantidad de movimientos que se deben realizar desde la posición inicial para llegar a la posición objetivo por ese camino. Es decir cada movimiento tiene costo unitario. Esta función de costo se utilizará para el algoritmo de búsqueda por costo uniforme.
    
    \item[Heurística] \hfill \\
  El costo heurístico a utilizar en la búsqueda A* toma como base a la distancia de Manhattan desde la posición actual hasta la posición objetivo. Se utiliza la distancia de Manhattan pues es simple de calcular y corresponde con la capacidad de movimiento del agente (arriba, abajo, izquierda y derecha). La distancia de Mahattan desde la posición $X = (x,y)$ hasta $F = (x_f,y_f)$ se define como:
    \begin{displaymath}
      d_m(X,F) = \abs{x-x_f} + \abs{y-y_f} 
    \end{displaymath}
    Pero la búsqueda A* se beneficia de agregar un factor pequeño para romper empates, este factor se puede definir de varias formas.
  Debido a esto la heurística se definirá como sigue:   
  \begin{displaymath}
      h(X) = d_m(X,F) + c(X,F) 
    \end{displaymath}   
    Donde $c$ corresponde al factor para romper empates, se ha decidido utiliza la siguiente función para esto:
      \begin{displaymath}
          c(X,F) = p \cdot d_m(X,F)
        \end{displaymath}   
    Este factor para romper empates fuerza al agente a escoger caminos más apropiados, si bien la optimalidad de la distancia de Manhattan se rompe con esto, debido a la naturaleza del problema, es muy poco probable que esto afecte para la mayoría de los casos, y los beneficios de velocidad entregados son bastantes. Para la implementación final de ha optado por tomar $p = 0.001$ en base a lo expuesto en la referencia [2] de la bibliografía. La optimalidad de la distancia de Manhattan ha sido demostrada en el apéndice B.

\end{description}

%----------------------------------------------------------------------------------------
% SECTION 2
%----------------------------------------------------------------------------------------

\newpage

\section{Métodos implementados}

\subsection{Algoritmos Implementados}
    \begin{itemize}
      \item{\textit{Búsqueda en Anchura: }} Este tipo de búsqueda es ineficiente en tiempo y espacio, pero al ser una búsqueda exhaustiva garantiza que encontrará la solución, y además se garantiza que será el camino más corto.
      \item{\textit{Búsqueda en Profundidad: }} Este tipo de búsqueda tiene menores requerimientos de memoria, pero tiene el problema que no garantiza que la solución encontrada sea la óptima. Además, no garantiza que se encuentre una solución, en caso de quedarse atrapada en un \textit{loop}, para evitar este problema se han marcado las posiciones recorridas.  
      \item{\textit{Búsqueda por Costo Uniforme: }} En este tipo de búsqueda se utiliza como criterio el costo real del camino, no se utilizan heurísticas ni aproximaciones, es decir, sigue siendo un método de búsqueda no informada. Esto hace que la búsqueda no sea tan eficiente como el otro agente basado en utilidad implementado (A*). Sin embargo como no requiere de aproximaciones ni heurísticas garantiza que la solución encontrada es óptima. 
      \item{\textit{Búsqueda A*: }}  En este tipo de búsqueda se utiliza como criterio tanto el costo real del camino y una heurística. La heurística utilizada influye mucho en el rendimiento y precisión del algoritmo, se dedica una sección completa al análisis de la función heurística.
    \end{itemize}       

\subsection{Análisis de los Algoritmos}
Se presenta a continuación una tabla resumen con los criterios de evaluación para algoritmos de búsqueda. Estos resultados son teóricos, en las siguientes secciones se mostrarán los resultados obtenidos por la implementación realizada.

\begin{table}[H]
\begin{center}

\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{Criterio} & \textbf{BFS}           & \textbf{DFS}           & \textbf{Costo Uniforme} & \textbf{A*}               \\ \hline
Tiempo            & $O(b^d)$ & $O(b^m)$ & $O(b^d)$  & $O(b^d)$    \\ \hline
Espacio           & $O(b^d)$ & $O(b\cdot m)$            & $O(b^d)$  & $O(b^d)$    \\ \hline
Optimalidad       & Sí                     & No                     & Sí                      & Depende de la heurística. {\small(*)} \\ \hline
Completitud       & Sí                     & No                     & Sí                      & Sí                        \\ \hline
\end{tabular}
\caption{Tabla comparativa de algoritmos de búsquedas}
\end{center}

\end{table}

Notar que en el peor caso A* sigue ocupando tiempo y memoria en orden exponencial, ya que se comportaría como una búsqueda en anchura, solo que ``guíada'' por la heurística. 
Además A* será O(n) en tiempo y espacio en el mejor caso, cuando se tiene una heurística óptima, donde n es el largo del camino solución.\\

{\small(*)} Si la heurística es admisible entonces el algoritmo A* es óptimo, en caso contrario la optimalidad no está garantizada. En el apéndice B se muestra que las heurísticas de distancia de Manhattan sin modificaciones es admisible y por lo tanto óptima, sin embargo, la distancia de Manhattan modificada por el factor rompe empates propuesta no es siempre óptima (aunque es más rápida generalmente).

\newpage
\subsection{Implementación}
\subsubsection{Diagramas de Clases}
\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale = 0.5]{images/diagram_busq}
        \caption{Diagrama de Clases}
    \end{center}
\end{figure}

    \begin{figure}[H]
  \centering
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=0.5\linewidth]{images/diagram_bea}
        \captionof{figure}{Búsqueda en Anchura}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=0.5\linewidth]{images/diagram_bep}
        \captionof{figure}{Búsqueda en Anchura}
    \end{minipage}
\end{figure}


    \begin{figure}[H]
  \centering
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=0.5\linewidth]{images/diagram_bcu}
        \captionof{figure}{Búsqueda por Costo Uniforme}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=0.5\linewidth]{images/diagram_bae}
        \captionof{figure}{Búsqueda A*}
    \end{minipage}
\end{figure}





\subsubsection{Pseudocódigo ``Clase Abstracta Búsqueda''}
\begin{lstlisting}
    def es_meta(self):
        """Comprueba si el jugador llego a la meta."""
        return self._posicion_jugador == self._meta

    def hay_solucion(self):
        """Comprueba si la busqueda encontro la solucion."""
        return len(self._abiertos) != 0
    
    def es_sucesor(self, candidato):
        """Comprueba si el candidato es un sucesor."""
        raise NotImplementedError
    
    def encontrar(self):
        """Encuentra el camino."""
        while self.hay_solucion():
            if self.es_meta():
                break
            self.proxima_posicion()
    
    def proxima_posicion(self):
        """Encuentra los sucesores."""
        raise NotImplementedError
\end{lstlisting}


\subsubsection{Pseudocódigo ``Búsqueda en Anchura''}
\begin{lstlisting}
    def es_sucesor(self, candidato):
        lista = list(self._abiertos)
        for i in xrange(len(lista)):
            if lista[i] == candidato:
                return True
        return False

    def proxima_posicion(self):
        mapa = self._laberinto.obtener_matriz_laberinto()
        mapa[self._posicion_jugador[0]][self._posicion_jugador[1]] = 4
        self._posicion_jugador = self._abiertos.popleft()
        mapa[self._posicion_jugador[0]][self._posicion_jugador[1]] = 2
        sucesores = self._laberinto.obtener_posiciones_libres(self._posicion_jugador)
        for sucesor in sucesores:
            if not self.es_sucesor(sucesor):
                self._abiertos.append(sucesor)
                self._camino_final.append((sucesor, self._posicion_jugador))
\end{lstlisting}

\subsubsection{Pseudocódigo ``Búsqueda por Costo Uniforme''}
\begin{lstlisting}
    def proxima_posicion(self):
        mapa = self._laberinto.obtener_matriz_laberinto()
        mapa[self._posicion_jugador[0]][self._posicion_jugador[1]] = 4
        nodo_actual = heappop(self._abiertos)
        self._costo_actual = nodo_actual[0]
        self._posicion_jugador = nodo_actual[1]
        mapa[self._posicion_jugador[0]][self._posicion_jugador[1]] = 2
        sucesores = self._laberinto.obtener_posiciones_libres(self._posicion_jugador)
        lista = list(self._abiertos)
        for sucesor in sucesores:
            costo = self._costo_actual + 1
            flag = False
            for i in xrange(len(lista)):
                if lista[i][1] == sucesor:
                    flag = True
                    if lista[i][0] >= costo:
                        lista[i][0] = costo
                        heapify(lista)
                        for j in xrange(0, len(self._camino_final)):
                            if self._camino_final[j][0] == sucesor:
                                self._camino_final[j] = (sucesor, self._posicion_jugador)
            if not flag:
                heappush(lista, [costo, sucesor])
                self._camino_final.append((sucesor, self._posicion_jugador))
        self._abiertos = lista
\end{lstlisting}


\newpage
\subsubsection{Pseudocódigo ``Búsqueda en Profundidad''}
\begin{lstlisting}
    def es_sucesor(self, candidato):
        lista = list(self._abiertos)
        for i in xrange(len(lista)):
            if lista[i] == candidato:
                return True
        return False

    def proxima_posicion(self):
        mapa = self._laberinto.obtener_matriz_laberinto()
        mapa[self._posicion_jugador[0]][self._posicion_jugador[1]] = 4
        self._posicion_jugador = self._abiertos.pop()
        mapa[self._posicion_jugador[0]][self._posicion_jugador[1]] = 2
        sucesores = self._laberinto.obtener_posiciones_libres(self._posicion_jugador)
        for sucesor in sucesores:
            if not self.es_sucesor(sucesor):
                self._abiertos.append(sucesor)
                self._camino_final.append((sucesor, self._posicion_jugador))
\end{lstlisting}

\subsubsection{Pseudocódigo ``Búsqueda A*''}
\begin{lstlisting}
    def _funcion_heuristica(self, sucesor):
        """Este metodo calcula el costo heuristico del sucesor dado.
        La heuristica utilizada es la distancia de Manhattan

        :param sucesor: Es una tupla (x,y) con las coordenadas de la posicion.
        """
        dx = abs(sucesor[0] - self._meta[0])
        dy = abs(sucesor[1] - self._meta[1])
        heuristica = dx + dy
        p = 0.001
        return heuristica * (1 + p)

    def proxima_posicion(self):
        mapa = self._laberinto.obtener_matriz_laberinto()
        mapa[self._posicion_jugador[0]][self._posicion_jugador[1]] = 4
        nodo_actual = heappop(self._abiertos)
        self._posicion_jugador = nodo_actual[1]
        self._costo_actual = nodo_actual[0] - self._funcion_heuristica(self._posicion_jugador)
        mapa[self._posicion_jugador[0]][self._posicion_jugador[1]] = 2
        sucesores = self._laberinto.obtener_posiciones_libres(self._posicion_jugador)
        lista = list(self._abiertos)
        for sucesor in sucesores:
            heuristica = self._funcion_heuristica(sucesor)
            flag = False
            for i in xrange(len(lista)):
                if lista[i][1] == sucesor:
                    flag = True
                    if lista[i][0] >= self._costo_actual + 1 + heuristica:
                        lista[i][0] = self._costo_actual + 1 + heuristica
                        heapify(lista)
                        for j in xrange(0, len(self._camino_final)):
                            if self._camino_final[j][0] == sucesor:
                                self._camino_final[j] = (sucesor, self._posicion_jugador)
            if not flag:
                heappush(lista, [self._costo_actual + 1 + heuristica, sucesor])
                self._camino_final.append((sucesor, self._posicion_jugador))

        self._abiertos = lista
\end{lstlisting}


\newpage
\subsection{Resultados Obtenidos}
A continuación se resumen los promedios de tiempo de ejecución (en segundos) obtenidos para cada algoritmo. Para la muestra se utilizó el mapa entregado inicialmente, se desactivó la parte gráfica y se el tamaño de muestra utilizado es $n = 10$. Los datos en bruto se pueden observar en el apéndice C.

\begin{table}[H]
\begin{center}
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{BFS} & \textbf{DFS}  & \textbf{Costo Uniforme}   & \textbf{A*}   \\ \hline
0.0009202 & 0.0003593 & 0.0010638 & 0.0004672
\\ \hline
\end{tabular}
\caption{Tiempos de Ejecución promedio para cada Algoritmo.}
\end{center}
\end{table}

En base a los promedios observados se puede ver que DFS entrega la búsqueda más eficiente. Seguido de la búsqueda A*, luego BFS y finalmente costo uniforme. La supremacía de la búsqueda en profundidad se puede deber a que el mapa en particular beneficia mucho a este tipo de estrategia. Su competidor más cercano (A*) pierde en eficiencia debido al costo de calcular la heurística y el costo del camino. En otro mapa (como el segundo mapa mostrado en el anexo A), la búsqueda en profundidad no sería tan eficiente, y es más, no retornaría un camino óptimo, debido a que avanzaría ciegamente sin preocuparse de la optimalidad.

Por otra parte es interesante notar los tiempos de la búsqueda por costo uniforme y en anchura. La búsqueda por costo uniforme, para esta instancia del problema de búsqueda, es naturalmente menos eficiente, ya que al definirse el costo como la cantidad de movimientos realizados desde el inicio hasta la posición actual, lo único que se esta haciendo es calcular el nivel del nodo en el árbol de búsqueda, lo cual conlleva a realizar un recorrido por niveles del árbol, que es exactamente lo mismo que realiza la búsqueda en anchura, con la diferencia que la búsqueda en anchura no pierde el tiempo calculando costos ni utilizando una cola con prioridad para determinar que sucesor escoger.

No se ha demostrado aquí la diferencia de tiempo producida por la elección de diferentes heurísticas, sin embargo, en la bibliografía revisada se indica que el uso de diferentes heurísticas provoca cambios en el rendimiento, idealmente la heurística debe ser fácil de calcular (se recomienda que tome un tiempo $O(1)$, aunque existen heurísticas que requieren más tiempo) y debe ser lo más cercana posible al costo real.

Se demostrará mediante el procedimiento estadístico ANOVA, realizado en Excel, que existe una diferencia entre los tiempos de ejecución de los algoritmos. Se muestra la tabla generada a continuación.

\begin{figure}[H]
    \begin{center}
        \includegraphics[scale = 0.5]{images/ANOVA}
        \caption{Tabla ANOVA}
    \end{center}
\end{figure}

En base al \textbf{valor p} que es menor a $0.01$ se puede afirmar que existe una diferencia significativa entre los tiempos de ejecución de los algoritmos. Esta conclusión es válida al menos para el mapa utilizado en las pruebas. Se requeriría un generador de mapas aleatorios para realizar un experimento más potente.

%----------------------------------------------------------------------------------------
% SECTION 3
%----------------------------------------------------------------------------------------
\newpage
\section{Resultados y Conclusiones}
Se ha completado satisfactoriamente el objetivo del taller I que correspondía a resolver el problema del laberinto utilizando los diferentes enfoques de resolución vistos en cátedra. Este trabajo ha contribuido en mejorar el entendimiento de las técnicas de diseño de algoritmos de búsqueda aprendidos en clases mediante su implementación.

Se ha mostrado además la clara diferencia que existe en los tiempos de ejecución entre los distintos enfoques de búsquedas, como se ha comprobado con el análisis presentado.  Además se ha mencionado la diferencia que produce la elección de una heurística apropiada en el rendimiento del algoritmo A*. 

Se debe mencionar también el comportamiento de la búsqueda en profundidad que en algunos casos logra superar la eficiencia de A*, sin embargo, como se puede ver con uno de los laberintos en el apéndice A, el camino que encontraría no siempre es óptimo (se dará muchas más vueltas de las necesarias).

A pesar de su rendimiento levemente inferior en la muestra tomada, se recomendaría utilizar A* (de hecho es muy utilizado en aplicaciones de búsqueda de caminos en vídeo juegos debido a su eficiencia), ya que a diferencia de búsqueda en profundidad, no caerá en caminos no óptimos, asumiendo que las heurísticas están bien definidas. 

Una observación que se debe hacer es reconsiderar el uso de la búsqueda por costo uniforme, dada la definición del costo como la cantidad de movimientos desde la posición inicial, sigue que su comportamiento es prácticamente idéntico al de búsqueda en anchura, ya que procederá a buscar por niveles. Sería diferente si existiesen diferentes tipos de suelo en el laberinto que tuviesen costos variables asociados a estos. También se debe mencionar que la búsqueda por costo uniforme es básicamente una búsqueda A* con una heurística de valor nulo,.

Un interesante problema que considerar sería agregar un elemento dinámico al ambiente, por ejemplo, un minotauro que recorriese el laberinto en busca de su víctima Teseo. Otro interesante agregado al problema, que no se realizó por falta de tiempo, sería un generador dinámico de laberintos aleatorios, con el objetivo de que las muestras utilizadas para los tiempos fueran totalmente aleatorias.

También es posible generar una extensión de los algoritmos que encuentren todas las soluciones, sin embargo, se consideró fuera del alcance de este trabajo. 

Por último queda mencionar los problemas encontrados durante el desarrollo del taller, a decir, la identificación de las posiciones ya visitadas, que correspondía a un problema del código original, y la reconstrucción de los caminos de solución, que por la estructura que tenía el código fue difícil de implementar.

%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\newpage
\bibliographystyle{apalike}

%Se presenta la bibliografía utilizada para el desarrollo del taller, desde los ejemplos de código utilizados, los fundamentos teóricos de los algoritmos, las herramientas para realizar el análisis de tiempo y memoria de los algoritmos y finalmente el procedimiento estadístico ANOVA.

\begin{thebibliography}{10} % 10 the total number of references
    % Libro guía
    \bibitem{Russell10} S. Russell {\em Artificial Intelligence.} 2010: A Modern Approach.
    %Heuristicas!
    \bibitem{StanfordA*} {\em Heuristics From Amit's Thoughts on Pathfinding.} Heuristics. Recuperado Junio 18, 2014, desde http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
    
    %Experiencias
    \bibitem{1} {\em A* PathFinding Algorithm in Pacman.} Recuperado Junio 18, 2014, desde http://www.xbdev.net/maths\_of\_3d/a\_star\_pathfinding/index.php
    
    %Problema del laberinto
    \bibitem{2} {\em Buscador de Caminos con Python.} Recuperado Junio 18, 2014, desde http://razonartificial.wordpress.com/2010/01/17/buscador-de-caminos-con-python/
    
    \bibitem{3} {\em Técnicas de Inteligencia Artificial para la Solución de Laberintos de Estructura Desconocida.} Recuperado Junio 18, 2014, desde http://revistas.utp.edu.co/index.php/revistaciencia/article/viewFile/3171/1933
    
    \bibitem{4} {\em  Algoritmo de backtracking recursivo y no recursivo para la resolución de un laberinto y su aplicación en SDL.} Recuperado Junio 18, 2014, desde http://www.academia.edu/4607412/Algoritmo\_de\_Backtracking\_Recursivo\_y\_no\_Recursivo\_para\_la\_Re-solucion\_de\_un\_Laberinto\_y\_su\_Aplicacion\_en\_SDL
    
    \bibitem{5} {\em El problema del Laberinto: una versión Orientada a Objetos en Python 3.x.} Recuperado Junio 18, 2014, desde http://ic1800a2011.wordpress.com/2013/11/19/031-el-problema-del-laberinto-una-version-orientada-a-objetos-en-python-3-x/
    
    \bibitem{6} {\em Laberintos con Python.} Recuperado Junio 18, 2014, desde http://calcifer.com.ar/blog/2013/2/8/laberintos-con-python/
    
    \bibitem{7} {\em Laberinto en Python.} Recuperado Junio 18, 2014, desde http://www.solveet.com/exercises/Laberinto/185/ solution-1304

    \bibitem{8} {\em Maze Solving.} Recuperado Junio 18, 2014, desde http://rosettacode.org/wiki/Maze\_solving\#Python

    %Busqueda A*
    \bibitem{9} {\em Solving mazes using Python: Simple recursivity and A* search.} Recuperado Junio 18, 2014 desde http://www.laurentluce.com/posts/solving-mazes-using-python-simple-recursivity-and-a-search/comment-page-1/

    \bibitem{10} {\em A-star Shortest Path Algorithm (Python recipe).} Recuperado Junio 18, 2014 desde http://code.activestate.com/recipes/577519-a-star-shortest-path-algorithm/
    \bibitem{11} {\em A-Star ( A* ) search algorithm implementation.} Recuperado Junio 18, 2014 desde http://www.emoticode.net/python/a-star-a-search-algorithm-implementation.html

    %Medicion de tiempo y memoria.
    \bibitem{12} {\em A guide to analyzing Python performance.} Recuperado Junio 18, 2014 desde http://www.huyng.com/posts/python-performance-analysis/
    
    \bibitem{13} {\em Is there any simple way to benchmark python script?} Recuperado Junio 18, 2014 desde http://stackoverflow.com/questions/1593019/is-there-any-simple-way-to-benchmark-python-script


\end{thebibliography}

\newpage
\begin{appendices}
  \renewcommand\thetable{\thesection\arabic{table}}
  \renewcommand\thefigure{\thesection\arabic{figure}}
  
  \section{Imágenes de los Resultados} 
    En este anexo se presentan los resultados obtenidos por cada algoritmo en diferentes laberintos.
  
  \subsection{Búsqueda en Anchura}
  \begin{figure}[H]
  \centering
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/bea_01}
        \captionof{figure}{Búsqueda en Anchura}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/bea_02}
        \captionof{figure}{Búsqueda en Anchura}
    \end{minipage}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \includegraphics[scale = 0.4]{images/bea_03}
        \caption{Búsqueda en Anchura: Camino Mapa 1}
    \end{center}
\end{figure}

  
    \begin{figure}[H]
  \centering
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/bea_01_m2}
        \captionof{figure}{Búsqueda en Anchura}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/bea_02_m2}
        \captionof{figure}{Búsqueda en Anchura}
    \end{minipage}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \includegraphics[scale = 0.4]{images/bea_03_m2}
        \caption{Búsqueda en Anchura: Camino Mapa 2}
    \end{center}
\end{figure}


    \begin{figure}[H]
  \centering
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=0.8\linewidth]{images/bea_01_m3}
        \captionof{figure}{Búsqueda en Anchura}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=0.8\linewidth]{images/bea_02_m3}
        \captionof{figure}{Búsqueda en Anchura}
    \end{minipage}
\end{figure}
  
  \begin{figure}[H]
    \begin{center}
        \includegraphics[scale = 0.4]{images/bea_03_m3}
        \caption{Búsqueda en Anchura: Camino Mapa 3}
    \end{center}
\end{figure}

  
  \subsection{Búsqueda en Profundidad}
  
      \begin{figure}[H]
  \centering
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=0.8\linewidth]{images/bep_01}
        \captionof{figure}{Búsqueda en Profundidad}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=0.8\linewidth]{images/bep_02}
        \captionof{figure}{Búsqueda en Profundidad}
    \end{minipage}
\end{figure}

  \begin{figure}[H]
    \begin{center}
        \includegraphics[scale = 0.4]{images/bep_03}
        \caption{Búsqueda en Profundidad: Camino Final}
    \end{center}
\end{figure}

  
  \subsection{Búsqueda por Costo Uniforme}
  
        \begin{figure}[H]
  \centering
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=0.8\linewidth]{images/bcu_01}
        \captionof{figure}{Búsqueda por Costo Uniforme}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=0.8\linewidth]{images/bcu_02}
        \captionof{figure}{Búsqueda por Costo Uniforme}
    \end{minipage}
\end{figure}

  \begin{figure}[H]
    \begin{center}
        \includegraphics[scale = 0.4]{images/bcu_03}
        \caption{Búsqueda por Costo Uniforme: Camino Final}
    \end{center}
\end{figure}
  
  
  \subsection{Búsqueda A*}
    
        \begin{figure}[H]
  \centering
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=0.8\linewidth]{images/bae_01}
        \captionof{figure}{Búsqueda A*}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=0.8\linewidth]{images/bae_02}
        \captionof{figure}{Búsqueda A*}
    \end{minipage}
\end{figure}

  \begin{figure}[H]
    \begin{center}
        \includegraphics[scale = 0.4]{images/bae_03}
        \caption{Búsqueda A*}
    \end{center}
\end{figure}
    
    \newpage

  \section{Admisibilidad de la Heurística}
  \subsection{Definiciones Previas}
    En este anexo se presentan las demostraciones de admisibilidad de la heurística propuesta. La admisibilidad de las heurísticas garantiza la optimalidad en el algoritmo A*.
    Se debe demostrar que las heurísticas propuestas son consistentes, esto implica que es admisible, y por tanto el algoritmo A* retornará una solución óptima, se define una heurística consistente como:
\begin{align*}
h(X) \leq c(X,P) + h(P)\\
h(G) = 0
\end{align*}

Donde se tiene:
\begin{itemize}
\item $h$ es una función heurística consistente.
\item $N$ es cualquier nodo del grafo.
\item $P$ es cualquier sucesor de $N$.
\item $G$ es cualquier nodo objetivo.
\item $c(N,P)$ es el costo de alcanzar el nodo $P$ desde $N$.
\end{itemize}

\subsection{Distancia de Manhattan}
Primero que todo motar que la heurística cumple con la condición $h(G) = 0$.

Ahora, para la demostración se definen los siguientes términos:
\begin{align*}
    dx_1 = \abs{x_n-x_f}\\
  dy_1 = \abs{y_n-y_f}\\
  dx_2 = \abs{x_{n+1}-x_f}\\
  dy_2 = \abs{y_{n+1}-y_f}
\end{align*}

Donde $X_n = (x_n,y_n)$, $X_{n+1} = (x_{n+1},y_{n+1})$ y $G = (x_f,y_f)$. 
Se pretende demostrar que: $dx1 + dy1 \leq 1 + dx2 + dy2$

Cualquier movimiento realizado conserva una de las coordenadas y modifica otra, por lo tanto $dx_1 = dx_2$ o $dy_1 = dy_2$.

Sin pérdida de generalidad, asumir $dx_1 = dx_2$ (la demostración sería análoga para el otro caso):
\begin{displaymath}
  dx_1 + dy_1 = dx_2 + dy_1
\end{displaymath}

La distancia pudo aumentar, en cuyo caso:
\begin{displaymath}
dx_1 + dy_1 \leq dx_2 + dy_2 \leq 1 + dx_2 + dy_2
\end{displaymath}

La distancia pudo disminuir en a lo más una unidad, en cuyo caso:
\begin{displaymath}
dx_1 +dy_1 = dx_2 + dy_2 + 1
\end{displaymath}
Que también está cubierto por el caso $\leq$, por lo tanto la distancia de Manhattan es consistente (y por lo tanto admisible) y al utilizar la búsqueda A* con esta heurística se obtendrá una solución óptima. Notar que la demostración se ha hecho sin considerar el factor rompe empates, debido a que este no conserva la optimalidad.

\newpage
  \section{Tablas de Datos}
  En este anexo se presentan las tablas de datos referentes a los tiempos de ejecución (en segundos) %y uso de memoria 
  de cada uno de los algoritmos implementados.
  \subsection{Tiempo de Ejecución}

\begin{table}[H]
\begin{center}
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{Muestra} & \textbf{BFS} & \textbf{DFS}  & \textbf{Costo Uniforme}   & \textbf{A*}   \\ \hline
1                & 0.000904     & 0.000397      & 0.001040                  & 0.000425      \\ \hline
2                & 0.000876     & 0.000346      & 0.001017                  & 0.000441      \\ \hline
3                & 0.000920     & 0.000344      & 0.001014                  & 0.000435      \\ \hline
4                & 0.000859     & 0.000457      & 0.001204                  & 0.000494      \\ \hline
5                & 0.000947     & 0.000338      & 0.001150                  & 0.000504      \\ \hline
6                & 0.001022     & 0.000341      & 0.001082                  & 0.000456      \\ \hline
7                & 0.001131     & 0.000356      & 0.001016                  & 0.000473      \\ \hline
8                & 0.000839     & 0.000332      & 0.001021                  & 0.000443      \\ \hline
9                & 0.000842     & 0.000334      & 0.001036                  & 0.000486      \\ \hline
10               & 0.000862     & 0.000348      & 0.001058                  & 0.000515      \\ \hline
\end{tabular}
\caption{Tiempos de Ejecución para cada Algoritmo.}
\end{center}
\end{table}

\end{appendices}


%----------------------------------------------------------------------------------------
%    DOCUMENT END
%----------------------------------------------------------------------------------------

\end{document}